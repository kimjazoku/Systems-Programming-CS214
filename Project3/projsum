Below is a comprehensive plan that outlines how you can build the shell project (“mysh”). This plan is divided into design, implementation, and testing stages, ensuring that each requirement is addressed.

---

## 1. Overall Architecture

- **Main Program:**  
  The entry point (typically `main()`) should:
  - Process command-line arguments. If an argument is provided, treat it as a batch file; if none, assume interactive mode.
  - Use `isatty(STDIN_FILENO)` to determine whether to run interactively (print welcome messages, prompts) or in batch mode (silent operation).

- **Single Input Loop:**  
  Implement one loop that reads and processes one command per iteration. This loop should:
  - Read input using the low-level `read()` function.
  - Buffer characters until a complete command (ending with a newline) is received.
  - Execute the command before beginning to read the next.

- **Command Processing and Execution:**  
  The command processing should be modular, with separate responsibilities for:
  - **Tokenization:** Breaking the input string into tokens, where tokens include words, redirection symbols (`<`, `>`) and the pipe symbol (`|`). Ensure comments (starting with `#`) are ignored.
  - **Parsing:** Once tokenized, figure out:
    - The command’s arguments.
    - Presence and type of redirection (input `<` and output `>`).
    - If a pipeline (`|`) is present, split the command into two subcommands.
    - Conditional execution using `and` and `or`.
    - Wildcard (glob) processing for tokens containing an asterisk (`*`).

- **Execution Engine:**  
  Create a function (or set of functions) responsible for:
  - **Built-in Commands:** Handling built-ins like `cd`, `pwd`, `which`, `exit`, and `die` without spawning child processes where possible.
  - **External Commands:** For non-built-in commands, use `fork()` to spawn a child process. Use `execv()` (not execvp or execlp) to execute commands.
  - **Pipes and Redirection:**  
    - For redirection, open the designated files with the appropriate flags (e.g., for output, open with truncation using mode 0640) and use `dup2()` to redirect standard input/output.
    - For pipelines, create a pipe using `pipe()`, then:
      - In the first child, redirect standard output to the pipe’s write end.
      - In the second child, redirect standard input from the pipe’s read end.
    - For batch mode, remember that any child processes should close the inherited standard input.

- **Wildcard Expansion:**  
  When you encounter a token with a wildcard (`*`):
  - Open the directory where the file is expected to reside.
  - Match file names using a simple pattern match (you can assume only one `*` occurs and it is in the last path segment).
  - Replace the token with the list of matching files (or leave it unchanged if no matches are found).

---

## 2. Step-by-Step Implementation Details

### A. Input Detection and Mode Handling
- **Interactive vs. Batch:**
  - Call `isatty(STDIN_FILENO)`.  
    - **If true:** Print a welcome message (e.g., “Welcome to my shell!”) and display the prompt `"mysh> "` before each command.
    - **If false:** Do not print any messages or prompt.
- **Redirection of Child Processes:**  
  When operating in batch mode, if launching child processes, explicitly close their standard input to avoid unintended blocking.

### B. Reading Input with `read()`
- Use the low-level `read()` function from `<unistd.h>`:
  - Read chunks of data and ensure you process them until you encounter a newline (`\n`).
  - Make sure your input loop waits for a full command (ending with a newline) before starting to process it.
  - Avoid blocking on input once a newline has been received by processing the buffered command promptly.

### C. Tokenizing and Parsing the Input
- **Tokenization:**  
  Split the input based on whitespace. Remember to treat `<`, `>`, and `|` as independent tokens.  
- **Parsing Components:**
  - **Redirection:**  
    - When encountering `<` or `>`, treat the following token as the file name and remove it from the argument list.
  - **Pipelines:**  
    - Look for the `|` token. If found, split the command into two parts, each with its own argument list and potential redirections.  
    - Note: Limit pipelines to two processes for this project.
  - **Conditionals:**  
    - Detect the optional leading `and` or `or` tokens (remember these do not contribute to the argument list).
    - Check the exit status of the previous command to determine whether the current command should execute.
  - **Wildcards:**  
    - For any token that contains a `*`, open the corresponding directory (using `opendir()`) and scan for matching file names (using `readdir()`).
    - Replace the token with the list of files if matches are found; otherwise, leave the token unchanged.

### D. Executing Commands
- **Built-in Commands:**  
  Implement functions for built-ins:
  - **cd:** Change the directory using `chdir()` and handle error messages if the directory does not exist.
  - **pwd:** Use `getcwd()` to fetch the current working directory and print it.
  - **which:** Search for a program’s path in `/usr/local/bin`, `/usr/bin`, and `/bin` (using `access()` to check execution rights).
  - **exit/die:** Terminate the shell. For `die`, print any arguments as error messages before exiting with a failure status.
- **External Commands:**  
  - **Forking:** Use `fork()` to create a child process.
  - **execv():** In the child, use `execv()` to execute the command, providing the correct path (determined either by built-ins or by your own search mechanism for bare names).
  - **Parent Process:**  
    - Wait for child processes to terminate using `waitpid()`.
    - Capture their exit status to use in conditional commands.
- **Handling Pipes:**
  - Before forking, create a pipe with `pipe()`.
  - In the forked children, use `dup2()` to set up redirection:
    - First child: set its standard output to the pipe’s write end.
    - Second child: set its standard input to the pipe’s read end.
  - Close the unneeded pipe ends in both children and the parent.

---

## 3. Testing and Debugging

- **Unit Test Functions:**  
  Develop separate functions to:
  - Test command parsing (including tokenization, conditional checking, redirection, and wildcard expansion).
  - Validate built-in commands behave as expected.
  - Simulate both interactive and batch modes.
- **Test Cases:**  
  Create sample script files (for batch mode) to test:
  - Single commands (e.g., `echo hello`).
  - Redirection (e.g., `foo bar < input.txt > output.txt`).
  - Pipelines (e.g., `foo | bar`).
  - Conditional commands with `and`/`or`.
  - Wildcard expansion in directories with known file sets.
- **Corner Cases:**  
  - Incorrect syntax (e.g., multiple redirection operators without proper operands).
  - Conditions that rely on the exit status of previous commands.
  - Verify that your loop does not call `read()` once a newline is encountered until the command has been executed.

- **Documentation and Makefile:**  
  - Write a clear `README` that documents your design decisions, partner information, and test plan.
  - Prepare a `Makefile` that compiles your project properly (ensuring all warnings are enabled and the code complies with POSIX standards).

---

## 4. Summary of the Build Process

1. **Initialization:**  
   - Parse command-line arguments.
   - Check mode (interactive vs. batch) with `isatty()`.

2. **Main Command Loop:**  
   - Use `read()` to get a command.
   - Print prompts and messages when in interactive mode.

3. **Command Processing:**  
   - Tokenize the command.
   - Handle comments, conditionals, wildcards, redirection, and pipes.
   - Build an argument array for each subcommand.

4. **Execution Phase:**  
   - Identify and execute built-in commands directly.
   - For external commands:
     - Fork child processes.
     - Set up redirection and pipelines using `dup2()`, `pipe()`.
     - Execute command with `execv()`.
   - Wait for and check the exit status to support conditional commands.

5. **Termination:**  
   - Exit cleanly when the `exit` or `die` command is encountered.
   - In interactive mode, print a goodbye message before termination.

6. **Testing and Debugging:**  
   - Implement a suite of tests covering typical and edge cases.
   - Keep logs or debug prints (possibly toggled with a debug flag) to trace the flow of commands in both interactive and batch modes.

---

By dividing the project into these manageable components and modules, you can implement, test, and debug your shell in incremental steps. This approach not only meets all the project requirements (like POSIX stream I/O, directory handling, process management with `fork()`, `dup2()`, and `pipe()`, and command parsing) but also sets up a modular codebase that is easier to maintain and extend later if needed.

Let me know if you need further details on any specific part (such as code snippets or more explanation on a particular feature)!
